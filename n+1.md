# N+1問題とその解決方法

## N+1問題とは

N+1問題は、GraphQLやORMでよく発生するパフォーマンス問題です。1つのクエリでN個のレコードを取得した後、それぞれのレコードに対して関連データを取得するために追加でN回のクエリが実行されることで、合計N+1回のクエリが発生する問題です。

## 具体例：SoldOutProductでの問題

### 問題のあるコード（修正前）

```typescript
t.int("deliveryItemCount", {
  resolve: async ({ id }) => {
    return await getPrismaClient().deliveryItem.count({
      where: {
        catalogItem: {
          productId: id,
        },
      },
    });
  },
});
```

### 何が起こるか

1. **最初のクエリ（1回）**: `soldOutProducts`クエリで10個の商品を取得
   ```sql
   SELECT * FROM "Product" WHERE ... LIMIT 10;
   ```

2. **追加クエリ（N回）**: 各商品の`deliveryItemCount`を取得するために10回のクエリが実行
   ```sql
   SELECT COUNT(*) FROM "DeliveryItem" di 
   JOIN "CatalogItem" ci ON di."catalogItemId" = ci.id 
   WHERE ci."productId" = 1;
   
   SELECT COUNT(*) FROM "DeliveryItem" di 
   JOIN "CatalogItem" ci ON di."catalogItemId" = ci.id 
   WHERE ci."productId" = 2;
   
   -- ... 残り8回
   ```

**結果**: 合計11回のクエリが実行される（1 + 10 = N+1）

## 解決方法：バッチリゾルバー

### バッチリゾルバーの実装

```typescript
// src/services/resolveProductDeliveryItemCount.ts
export const getProductDeliveryItemCountMap = async (
  prisma: PrismaTransactionClient,
  productIds: number[]
): Promise<Map<number, number>> => {
  const result = await prisma.$queryRaw`
    SELECT ph."productId", COUNT(ph."productId") 
    FROM "DeliveryItem" di, "ProductHistory" ph 
    WHERE di."productHistoryId" = ph.id 
    AND ph."productId" IN (${Prisma.join(productIds)}) 
    GROUP BY ph."productId"
  `;

  return new Map([
    ...result.map(({ productId, count }) => [productId, Number(count)]),
    // COUNTが0のとき、結果セットからproductIdが抜けてしまうので補完する
    ...difference(productIds, result.map(({ productId }) => productId))
      .map((productId) => [productId, 0])
  ]);
};

const resolveProductDeliveryItemCount = createBatchResolver(
  getProductDeliveryItemCountMap
);
```

### 修正後のコード

```typescript
t.int("deliveryItemCount", {
  resolve: async ({ id }) => {
    return (await resolveProductDeliveryItemCount(getPrismaClient(), id)) ?? 0;
  },
});
```

### 改善後のクエリ実行

1. **最初のクエリ（1回）**: `soldOutProducts`クエリで10個の商品を取得
   ```sql
   SELECT * FROM "Product" WHERE ... LIMIT 10;
   ```

2. **バッチクエリ（1回）**: 全商品の`deliveryItemCount`を一度に取得
   ```sql
   SELECT ph."productId", COUNT(ph."productId") 
   FROM "DeliveryItem" di, "ProductHistory" ph 
   WHERE di."productHistoryId" = ph.id 
   AND ph."productId" IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) 
   GROUP BY ph."productId";
   ```

**結果**: 合計2回のクエリのみ実行される

## バッチリゾルバーの仕組み

### createBatchResolverの動作

1. **リクエスト収集**: 同一のGraphQLリクエスト内で呼び出された全ての`resolveProductDeliveryItemCount`呼び出しを収集
2. **バッチ実行**: 収集されたIDをまとめて1つのクエリで実行
3. **結果分配**: 各リゾルバーに対応する結果を返却

### 実装のポイント

```typescript
// 0件の場合の補完処理
...difference(productIds, result.map(({ productId }) => productId))
  .map((productId) => [productId, 0])
```

COUNTクエリでは、該当レコードが0件の場合、結果セットにそのIDが含まれません。そのため、明示的に0を設定する必要があります。

## パフォーマンス比較

| 商品数 | 修正前（N+1） | 修正後（バッチ） | 改善率 |
|--------|---------------|------------------|--------|
| 10     | 11回          | 2回              | 82%削減 |
| 100    | 101回         | 2回              | 98%削減 |
| 1000   | 1001回        | 2回              | 99.8%削減 |

## 他の解決方法

### 1. DataLoader（推奨）
Facebook製のライブラリで、自動的にバッチ処理とキャッシュを提供

### 2. JOIN クエリ
最初のクエリで関連データも一緒に取得

### 3. サブクエリ
SELECT文内でサブクエリを使用して関連データを取得

## まとめ

N+1問題は、GraphQLアプリケーションでよく発生するパフォーマンス問題です。バッチリゾルバーを使用することで、複数のクエリを1つにまとめ、大幅なパフォーマンス改善を実現できます。

特に、リスト表示やページネーションが含まれるクエリでは、N+1問題が発生しやすいため、事前にバッチリゾルバーの実装を検討することが重要です。
